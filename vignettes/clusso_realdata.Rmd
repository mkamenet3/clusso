---
title: "Running *clusso* with Real Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro to clusso}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

#Introduction

This package is still under development. Please [report any bugs](https://github.com/mkamenet3/clusso/issues).


Load `clusso`package:

```{r, message=FALSE, warning=FALSE}
library("clusso")

```


## Using `clusso` with real data (Breast Cancer in Japan)

### Prepare Data

We start by setting the seed using the `set.seed()` to ensure that the simulation is reproducible. We load the data that comes with the `clusso` package with `data("japanbreastcancer")`.


```{r}
set.seed(8282017)

#load data
data("japanbreastcancer")
load("../data/japanbreastcancer.RData")
```


To explore the 4 data sets that are part of `japanbreastcancer`, we apply the `head()` function to each of the data sets.
1. `utmJapan`: data set containing a unique identifier for each centroid (*id*), x-coordinate in UTM (*utmx*), and y-coordinate in UTM (*utmy*)
1. `japan.poly2`: polygon tesselations
1. `japan.prefect2`: boundaries for the prefects (geographical boundaries) of the region.
1. `jbc`: data set containting a unique identifier for each centroid (*id*), period of observation (categorical variable with 5 levels, *period*), death count (*death*), expected death count (*expdeath*). These data are simulated (with some noise) based on observed data.



```{r}
#inspect
head(utmJapan)
head(japan.poly2)
head(japan.prefect2)
head(jbc)
```

From the polygons (`dframe.poly2`) data set we extract the second and third columns, only the x and y coordinates of the polygons and create `japan.poly2`. From the prefect boundaries (`dframe.prefect2`) data set, we extract the second through fifth columns - the two x and two y coordinates of the polygons boundaries and create `japan.prefect2`.



### Set global conditions

When using `clusso`, there are certain global parameters that need to be set

There are two types of models we want to run: a quasi-poisson and Poisson model. Specifying this argument will make the output nicer.

```{r}
#Initial inputs
mods <- c("QuasiPoisson", "Poisson")
```

We take the easting and northing coordinates from the `utmJapan` dataset, set the easting coordinate, `utmx`, to `x` and the northing coordinate, `utmy`, to `y`. Each is divided by 1000 to change the scale from meters to kilometers.


```{r}
x <- utmJapan$utmx/1000
y <- utmJapan$utmy/1000
```

Below, we set the maximum radius for a cluster to 20 km (`rMax=20`) based on scientific knowledge of the area and our definition of a meaningful cluster, set the number of unique time periods to 5 (`Time=5`), number of simulations to be run to 11 (`nsim=11`), and set a floor for overdispersion to avoid estimating underdispersion (`overdispfloor=TRUE`). 


```{r}
rMax <- 20 
Time <- 5
overdispfloor <- TRUE

```


### Running the models

The first step is to create a `clst` object using the `toclusso()` function. By applying `str()` to `clst`, we see that the `clst` object neatly organizes the data into required covariates (expected counts, observed counts, and timeperiod are required), and other covariates (omitted here). If you have additional covariates, additional covariates will be included in the model and will not be penalized under the LASSO.


```{r}
clst <- toclusso(jbc, expected = expdeath, observed=death,timeperiod = period)
class(clst)
str(clst)
```

To perform the lasso cluster detection, we use the function `clusso()`. 

The first argument is the `clst` object created above, which contains the observed counts, expected counts, and respective time period (as a categorical factor). These are part of the required data. If there are additional covariates we want to include in our model (to be excluded from being penalized by the lasso), then we can include them in the `toclusso()` function.

The next two arguments are `x` and `y`, which are the UTM easting and northing coordinates, scaled to be in kilometers. 

The fourth argument is the number of time periods measurements were taken during (`Time`, or 5 in our data). 

The fifth argument species that our coordinates are indeed UTM. The default is lat/lon coordinates.

The sixth argument is `analysis`. The only current option is `both`, which will perform both the spatial and spatio-temporal analyses. 
The final required argument is `maxclust`. This is the maximum number of actual clusters expected in the given area. This is based on scientific knowledge of the area. For the japanese breast cancer data, we set `maxclust=10`.


For additional functionality, if you do not have expected counts readily available, they can be calculated using the auxiliary function `calcexpected()`, from the `clusso` package.

```{r}
head(calcexpected(jbc$death, factor(jbc$period), jbc$id, family="poisson"))
```


The output of `clusso()` is assigned to the object `resreal`. `resreal` is a large list of lists. The recommended way to explore the results is to explore the `names(resreal)` and select each sub-list of interest.

```{r}
system.time(resreal <- clusso(clst, x,y, rMax, Time, utm=TRUE, analysis="both", maxclust=11))

```

We can also use the function `clussopretty()` to create a nice table for the number of clusters detected:

```{r}
clussopretty(resreal, analysis="both", clusteridentify=FALSE)

names(clussopretty(resreal, analysis="both", clusteridentify=TRUE))

```


With the argument `clusteridentify=TRUE`, centroid indices (by time period) are extracted. Since these lists are very long, output is left to the user to explore:

```{r, eval=FALSE}
clussopretty(resreal, analysis="both", clusteridentify=TRUE)
clussopretty(resreal, analysis="both", clusteridentify=TRUE, clusterRR = 1.05)
clussopretty(resreal, analysis="both", clusteridentify=TRUE, clusterRR = "background")
```



More importantly, however, if we have polygons and boundary files, we can use the `easyplot()` function.

### Maps

Create maps using the `easyplot()` function.

```{r}
pdfname <- paste0("out",".pdf")
easyplot(japan.prefect2, japan.poly2 ,pdfname, resreal$rrcolors, mods, space="both", probmap=FALSE, obs=TRUE,rr=TRUE)
easyplot(japan.prefect2, japan.poly2 ,pdfname, resreal, mods, space="BIC", probmap=FALSE,rr=TRUE)


```

Lastly, we can create plots of the coefficient paths with the function `clussoplot()`:

```{r}
clussoplot(resreal, analysis="both", Time=5)
```




## Comparison to Cross-Validation

We continue with the same dataset as above, but now explore results by $k$ fold cross-validation. All initial inputs are assumed to be the same.

```{r}
#Initial inputs
cv <- 10 #how many folds for cv

#perform clusso using cv
system.time(rescv<- clusso(clst, x,y, rMax, Time, utm=TRUE, analysis="both", cv=cv))

```

```{r}
clussopretty(rescv, analysis="both", clusteridentify=FALSE, cv=TRUE)
```








## Real Data Example with Covariates

We can continue with the Japanese breast cancer dataset imported above. 

We will again checkout the `head()` of the dataframe, `jbc`. 



```{r}
#Set-up
head(jbc)
```


There are 5 additional covariates, `covar1` - `covar5` that we will want to adjust for as unpenalized terms in the LASSO.


We will need to recreate our `clst` object using the `toclusso()` function, setting the argument `covars=TRUE`.

```{r}
clst <- toclusso(jbc, expected = expdeath, observed = death, timeperiod = period,
                 covars=TRUE, id = id)
str(clst)
system.time(rescovars <- clusso(clst, x,y, rMax, Time, utm=TRUE, analysis="both"))

```

Use `clussopretty()` to create a nice table of clusters detected:

```{r}
clussopretty(rescovars, analysis="both", clusteridentify = FALSE)
```



### Maps

Create maps using `easyplot()`:


```{r}
pdfname <- paste0("outcovars", ".pdf")

easyplot(japan.prefect2, japan.poly2 ,pdfname, rescovars$rrcolors, mods, space="both",
         probmap=FALSE, obs=TRUE,rr=TRUE)
```

