---
title: "Running *clusso* with Case-Control Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro to clusso II}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height = 5, fig.width = 8)
```

#Introduction

This package is still under development. Please [report any bugs](https://github.com/mkamenet3/clusso/issues).

Messages from `clusso` have been suppressed for this tutorial, but there are many messages generated that we hope the user will find helpful. Feedback is welcome [here](https://github.com/mkamenet3/clusso/issues).

Load `clusso` package:

```{r, message=FALSE, warning=FALSE}
library("clusso")

```


## Using `clusso` with case-control data 

### Prepare Data

We load four datasets that comes with the `clusso` package:

```{r}
#load data
data("ccsjbc")
data("utmJapan")
data("japan.poly2")
data("japan.prefect2")

```


These datasets contain:

1. `ccsjbc`: data set containting a unique identifier for each centroid (*id*), period of observation (categorical variable with 5 levels, *period*), number of cases per each geographic unit (*numcases*), the total number of cases and controls from each geographic unit (*n*). These data are simulated.
1. `utmJapan`: data set containing a unique identifier for each centroid (*id*), x-coordinate in UTM (*utmx*), and y-coordinate in UTM (*utmy*)
1. `japan.poly2`: polygon tesselations
1. `japan.prefect2`: boundaries for the prefects (geographical boundaries) of the region.


To explore the 4 data sets, we apply the `head()` function to each of the data sets.



```{r}
#inspect
head(utmJapan)
head(japan.poly2)
head(japan.prefect2)
head(ccsjbc)
```

### Set global conditions

When using `clusso`, there are certain global parameters that need to be set.

We take the easting and northing coordinates from the `utmJapan` dataset, set the easting coordinate, `utmx`, to `x` and the northing coordinate, `utmy`, to `y`. Each is divided by 1000 to change the scale from meters to kilometers.


```{r}
x <- utmJapan$utmx/1000
y <- utmJapan$utmy/1000
```

Below, we set the maximum radius for a cluster to 20 km (`rMax=20`) based on scientific knowledge of the area and our definition of a meaningful cluster, set the number of unique time periods to 5 (`Time=5`). 


```{r}
rMax <- 20 
Time <- 5
```


### Running the models



The output of `clusso()` is assigned to the object `resreal`. `resreal` is a large list of lists. The recommended way to explore the results is to explore the `names(resreal)` and select each sub-list of interest.

```{r}
head(ccsjbc)

system.time(resrealccs <- clusso(df=ccsjbc, expected = n, observed = numcases,timeperiod = factor(period), covars=FALSE,
             x= x,y = y, rMax =  rMax, utm=TRUE, analysis="both", model="binomial",maxclust=11))

```


```{r}
clussopretty(resrealccs, analysis="both", model="binomial",clusteridentify=FALSE)
```


Lastly, we can create plots of the coefficient paths with the function `clussoplot()`:

```{r}
clussoplot(resrealccs, analysis="both", model="binomial",Time=5)
```


## Comparison to Cross-Validation

We continue with the same dataset as above, but now explore results by $k$ fold cross-validation. All initial inputs are assumed to be the same.


```{r}
#perform clusso using cv (5 folds)
system.time(resccscv <- clusso(ccsjbc, expected = n, observed = numcases,timeperiod = factor(period), covars=FALSE, 
                               x= x,y = y, rMax =  rMax, utm=TRUE, analysis="both", model="binomial",maxclust=11, cv=5))
clussopretty(resccscv, analysis="both", model="binomial",clusteridentify=FALSE, cv=TRUE)

clussoplot(resccscv, analysis="both",model="binomial", Time=5, cv=TRUE)
```

## Real Data Example with Covariates

We continue with the case-control data from Japan. We will again checkout the `head()` of the dataframe, `ccsjbc`. 


```{r}
head(ccsjbc)
```


There are 5 additional covariates, `covar1` - `covar5` that we will want to adjust for as unpenalized terms in the LASSO.


We now set the argument `covars=TRUE` to tell `clusso()` to identify the covariates and to include them in as unpenalized terms in the LASSO model.



```{r}
system.time(resccscovars<- clusso(ccsjbc, expected = n, observed=numcases,timeperiod = factor(period), covars=TRUE, 
                               x= x,y = y, rMax =  rMax, utm=TRUE, analysis="both", model="binomial",maxclust=11))

```



```{r}
clussopretty(resccscovars, analysis="both", model="binomial",clusteridentify = FALSE)
```


We can also extract the coefficients for the unpenalized terms and undo the log-link by exponentiating:

```{r}
exp(resccscovars$lassoresult.qp.st$lasso$beta[-c(1:66870), resccscovars$lassoresult.qp.st$numclust.qbic+1])
```






































