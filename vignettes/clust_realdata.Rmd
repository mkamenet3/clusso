---
title: "Running *clust* with Real Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro to clust}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

#Introduction

This package is still under development. Please [report any bugs](https://github.com/mkamenet3/cluST/issues).


Load `clust`package:

```{r, message=FALSE, warning=FALSE}
library("clust")
#library("Matrix")

#load dev version R scripts
# file.sources = list.files("../R/",pattern="*.R")
# sapply(paste0("../R/",file.sources),source,.GlobalEnv)
# load("../data/japanbreastcancer.RData")
```


## Using `clust` with real data (Breast Cancer in Japan)

### Prepare Data

We start by setting the seed using the `set.seed()` to ensure that the simulation is reproducible. We load the data that comes with the `clust` package with `data("japanbreastcancer")`.


```{r}
set.seed(8282017)

#load data
data("japanbreastcancer")
```


To explore the 4 data sets that are part of `japanbreastcancer`, we apply the `head()` function to each of the data sets.
1. `utmJapan`: data set containing a unique identifier for each centroid (*id*), x-coordinate in UTM (*utmx*), and y-coordinate in UTM (*utmy*)
1. `dframe.poly2`: polygon tesselations
1. `dframe.prefect2`: boundaries for the prefects (geographical boundaries) of the region.
1. `japanbreastcancer`: data set containting a unique identifier for each centroid (*id*), period of observation (categorical variable with 5 levels, *period*), death count (*death*), expected death count (*expdeath)



```{r}
#inspect
head(utmJapan)
head(dframe.poly2)
head(dframe.prefect2)
head(japanbreastcancer)
```

From the polygons (`dframe.poly2`) data set we extract the second and third columns, only the x and y coordinates of the polygons and create `japan.poly2`. From the prefect boundaries (`dframe.prefect2`) data set, we extract the second through fifth columns - the two x and two y coordinates of the polygons boundaries and create `japan.prefect2`.


```{r}
#take what we need
japan.poly2 <- dframe.poly2[,2:3]
japan.prefect2 <- dframe.prefect2[,2:5]

```

### Set global conditions

When using `clust`, there are certain global parameters that need to be set

There are two types of models we want to run: a quasi-poisson and Poisson model. Specifying this argument will make the output nicer (**TODO: CHANGE THIS TO OPTIONAL, CREATE REASONABLE DEFAULTS**)

```{r}
#Initial inputs
mods <- c("QuasiPoisson", "Poisson")
```

We take the easting and northing coordinates from the `utmJapan` dataset, set the easting coordinate, `utmx`, to `x` and the northing coordinate, `utmy`, to `y`. Each is divided by 1000 to change the scale from meters to kilometers.


```{r}
x <- utmJapan$utmx/1000
y <- utmJapan$utmy/1000
```

Below, we set the maximum radius for a cluster to 20 km (`rMax=20`) based on scientific knowledge of the area and our definition of a meaningful cluster, set the number of unique time periods to 5 (`Time=5`), number of simulations to be run to 10 (`nsim=10`), and set a floor for overdispersion to avoid estimating underdispersion (`overdispfloor=TRUE`). 


```{r}
rMax <- 20 
Time <- 5
overdispfloor <- TRUE

```


### Running the models

The first step is to create a `clst` object using the `toclust()` function. By applying `str()` to `clst`, we see that the `clst` object neatly organizes the data into required covariates (expected counts, observed counts, and timeperiod are required), and other covariates (omitted here). If you have additional covariates, additional covariates will be included in the model and will not be penalized under the LASSO.


```{r}
clst <- toclust(japanbreastcancer, expected = expdeath, observed=death,timeperiod = period)
class(clst)
str(clst)
```

To perform the lasso cluster detection, we use the function `clust()`. 

The first argument is the `clst` object created above, which contains the observed counts, expected counts, and respective time period (as a categorical factor). These are part of the required data. If there are additional covariates we want to include in our model (to be excluded from being penalized by the lasso), then we can include them in the `toclust()` function.

The next two arguments are `x` and `y`, which are the UTM easting and northing coordinates, scaled to be in kilometers. 

The fourth argument is the number of time periods measurements were taken during (`Time`, or 5 in our data). 

The fifth argument species that our coordinates are indeed UTM. The default is lat/lon coordinates.

The sixth argument is `analysis`. The only current option is `both`, which will perform both the spatial and spatio-temporal analyses. 
The final required argument is `maxclust`. This is the maximum number of actual clusters expected in the given area. This is based on scientific knowledge of the area. For the japanese breast cancer data, we set `maxclust=10`.


For additional functionality, if you do not have expected counts readily available, they can be calculated using the auxiliary function `calcexpected()`, from the `clust` package.

```{r}
head(calcexpected(japanbreastcancer$death, japanbreastcancer$period, japanbreastcancer$id, family="poisson"))
```


The output of `clust()` is assigned to the object `resreal`. `resreal` is a large list of lists. The recommended way to explore the results is to explore the `names(resreal)` and select each sub-list of interest.

```{r}
system.time(resreal <- clust(clst, x,y, rMax, Time, utm=TRUE, analysis="both", maxclust=10))
names(resreal)
```

We can also use the function `clustpretty()` to create a nice table for the number of clusters detected:

```{r}
clustpretty(resreal, analysis="both", clusteridentify=FALSE)

names(clustpretty(resreal, analysis="both", clusteridentify=TRUE))
clustpretty(resreal, analysis="both", clusteridentify=TRUE)

clustpretty(resreal, analysis="both", clusteridentify=TRUE, clusterRR = 1.05)
clustpretty(resreal, analysis="both", clusteridentify=TRUE, clusterRR = "background")
```



More importantly, however, if we have polygons and boundary files, we can use the `easyplot()` function.

### Maps

Create maps using the `easyplot()` function.

```{r}
pdfname <- paste0("jbc_analysis_2019_03_19",".pdf")
easyplot(japan.prefect2, japan.poly2 ,pdfname, resreal$rrcolors, mods, space="both", probmap=FALSE, obs=TRUE,rr=TRUE)
easyplot(japan.prefect2, japan.poly2 ,pdfname, resreal, mods, space="BIC", probmap=FALSE,rr=TRUE)


```


### Diagnostics of Clusters Detected

Finally, we can extract the number of clusters detected by each criterion and compile the information into an easy-to-read table:






**TODO: FIX BELOW 2019-03-19**

## Comparison to Cross-Validation


```{r}
#load data
data("japanbreastcancer")

#inspect
head(utmJapan)
head(dframe.poly2)
head(dframe.prefect2)
head(japanbreastcancer)

#take what we need
japan.poly2 <- dframe.poly2[,2:3]
japan.prefect2 <- dframe.prefect2[,2:5]

```


```{r}
#Initial inputs
mods <- c("QuasiPoisson", "Poisson")
x <- utmJapan$utmx/1000
y <- utmJapan$utmy/1000
rMax <- 20 
Time <- 5
overdispfloor <- TRUE
cv <- 10 #how many folds

clst <- toclust(japanbreastcancer, expected = expdeath, observed=death,timeperiod = period, covars = FALSE)
system.time(res<- clust(clst, x,y, rMax, Time, utm=TRUE, analysis="both", cv=cv))

```

```{r}

model <- c(rep("Poisson",2), rep("Quasi-Poisson",2))
st <- rep(c("Space", "Space-Time"),2)
numclust.cv <- c(res$lassoresult.p.s$numclust.cv, res$lassoresult.p.st$numclust.cv, 
                  res$lassoresult.qp.s$numclust.cv, res$lassoresult.qp.st$numclust.cv)


(table.clusterscv <- cbind(model, st, numclust.cv))


#WRITE TO CSV
print(table.clusterscv)
write.csv(table.clusterscv, file="tableclusters_cv.csv", row.names=TRUE)
```

### Maps

```{r}
#save results
filename <- paste0("jbc_analysis_cv",".RData")
save(res, file = filename)


#Create Empty PDF to Map Onto
pdfname <- paste0("jbc_analysis_cv",".pdf")

easyplot(japan.prefect2, japan.poly2 ,pdfname, res$rrcolors, mods, space="both", probmap=FALSE, cv=10, obs=TRUE, rr=TRUE)

```


## Real Data Example with Covariates

Import geography data:

```{r}
#load data
data("japanbreastcancer")

#inspect
head(utmJapan)
head(dframe.poly2)
head(dframe.prefect2)
head(japanbreastcancer)

#take what we need
japan.poly2 <- dframe.poly2[,2:3]
japan.prefect2 <- dframe.prefect2[,2:5]


```


```{r}
#Set-up
head(japanbreastcancer)
head(utmJapan)
set.seed(1)
#add a couple of covariates to the dataframe
covar1 <- rnorm(n = nrow(japanbreastcancer),mean = 500, sd = 30)
covar2 <- rpois(n = nrow(japanbreastcancer), lambda = japanbreastcancer$expdeath)
covar3 <- rbinom(n = nrow(japanbreastcancer), size = 50, prob = 0.7)
covar4 <- rbinom(n = nrow(japanbreastcancer), 1, 0.5)
covar5 <- rbinom(n = nrow(japanbreastcancer), 1, 0.2)

#add new covariates to dataframe
df <- cbind.data.frame(japanbreastcancer[,-1], covar1, covar2, covar3, covar4, covar5)

#check out the new dataframe
head(df)

#assume this is what you start with
```


```{r}
#Initial inputs
mods <- c("QuasiPoisson", "Poisson")
x <- utmJapan$utmx/1000
y <- utmJapan$utmy/1000
rMax <- 20 
Time <- 5
overdispfloor <- TRUE

```

Run **clust**.

```{r}
clst <- toclust(df, expected = expdeath, observed = death, timeperiod = period, covars=TRUE)
system.time(res <- clust(clst, x,y, rMax, Time, utm=TRUE, analysis="both"))

```

### Maps


```{r}
#save results
filename <- paste0("jbc_analysis_covars",".RData")
save(res, file = filename)


#Create Empty PDF to Map Onto
pdfname <- paste0("jbc_analysis_covars",".pdf")

easyplot(japan.prefect2, japan.poly2 ,pdfname, res$rrcolors, mods, space="both", obs=TRUE, obs=TRUE, obs=TRUE,rr=TRUE)
```

